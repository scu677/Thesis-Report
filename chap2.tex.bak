\chapter{Background}
\label{chap:figtab}
\label{chap}
\section{Clowder}
Clowder is made up of various components, and some of these components have been worked on by researchers in the department. The goal of this project is to complete the Clowder system by developing the remaining components, which are to solve the issue of user accessibility and system management. Generally Clowder has been designed to manage access of cluster of test machines, mainly for testing new operating systems. But as this requires a flexible user interface and database to complete this components, we have improved the existing user interface by adding a dynamic web interface which is extended to the back end with more functionality. The background components of Clowder includes  a  DHCP server with Preboot Execution Environment (PXE)  that allow the test machines to be boot up remotely by users for testing. The test machines do a PXE boot and by using the DHCP to get IP then request for files. 
\section{PXE and DHCP}
PXE is a standard Internet protocol widely deployed using DHCP which help to distribute IP. This process forms a DHCP conversation between clients and servers. To ensure that the meaning of the client-server interaction is standardized as well, certain vendor option fields in DHCP protocol are used, which are allowed by the DHCP standard. The operations of standard DHCP servers that serve up IP addresses will not be disrupted by the use of the extended protocol \cite{PXE}.
The client initiates the protocol by broadcasting a DHCPDISCOVER containing an extension that identifies the request as coming from a client that implements the PXE protocol. The client then discovers a Boot Server of the type selected and receives the name of an executable file on the chosen Boot Server \cite{PXE}. These files are managed with a Network File System (NFS) and TFTP, which allow users to access files across networks. This processes serves as the main function of Clowder system as a testing tool.
\section{SQL}
 SQL is a special purpose programming language designed for managing information in a relational database management system (RDBMS). For example it can used to record information about an organization and their activities. So by using a relational database, you can save this information as two tables that represent two distinct entities: organization and activities. Here information about an organization and activities is stored in two different tables with unique identifications (ID). In the design of some front end functionality extended to back end, we used a SQL JOIN query for combination of different database data where our algorithms requires to merge multiple data for some query request. A SQL JOIN is a Structured Query Language (SQL) instruction to combine data from two sets of tables \cite{SQLJOIN}. To associate them together, the entity is described with a primary key referring to its ID and a foreign key referring to the other table. SQL JOIN is applied by joining two entities tables using the relationship established with the foreign key. There are different types of join query which includes INNER: for collecting records that have matching values of two tables, OUTER: for collecting all records matching from either left or right tables, and RIGHT: for collecting records from right table and match with the record of other tables. This concept was used in this project to accomplished some of the functionality we have specified.
\section{Go Struct and Methods} \label{gostruct}
In Go programming language a struct replaces the concept of class as used in other Object Oriented Programming languages. Go support the concept of methods like Java for example. But the difference is that in Java, methods are defined within a class, while in Go, methods are associated with a struct. A struct is a type that contains some fields\cite{Struct}. These fields have data types that represent their values. We can initialize this struct by creating an instance of it inside other functions \cite{Method}. The method is a function with name that has a receiver argument which include the struct type. In this project, I used the struct to create type of machine, reservation, disk and NIC. Inside this struct we have several methods that contains the algorithms that process different  queries and schema actions. The method contains difference receiver types that represent the entities of the hardware in the system, and are used as arguments in the various functions. 



